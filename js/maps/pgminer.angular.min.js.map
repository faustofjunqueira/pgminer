{"version":3,"sources":["pgminer.angular.min.js","js/config/config.js","js/ctrl/docController.js","js/directive/documentation.js","js/service/parametroFactory.js","js/service/retornoFactory.js"],"names":["angular","module","app","controller","$scope","parametroFactory","retornoFactory","listaFuncoes","nome","descricao","cabecalho","parametros","criar","retorno","directive","templateUrl","restrict","scope","listaFuncao","$element","$attrs","this","teste","alert","link","$attr","ctrl","escolhida","escolherFuncao","funcao","service","tipo"],"mappings":"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","file":"../pgminer.angular.min.js","sourcesContent":[null,"angular.module('pgminer',[]);\n\n(function(){\n\n})(angular.module('pgminer'));","(function(app){\n\n  app.controller('DocController', function($scope,parametroFactory, retornoFactory){\n    $scope.listaFuncoes = [\n      {\n        nome: 'apply_inverse_sigmoid',\n        descricao:'Aplica a função inversa da sigmoid sobre cada elemento x 1da matriz m. Inversa da sigmoid: -log( 2.0/(x+1.0) -1.0)/16.0',\n        cabecalho:'apply_inverse_sigmoid(in m matrix, out c matrix) RETURNS matrix',\n        parametros: [\n          parametroFactory.criar('m', 'matrix', 'Matriz de valores')\n        ],\n        retorno:[\n          retornoFactory.criar('c', 'matrix', 'Matriz com valores aplicados na função')\n        ]\n      },\n      {\n        nome: 'apply_sigmoid',\n        descricao:'Aplica a função sigmoid sobre cada elemento x da matriz m. Sigmoid: 2.0/(1.0 + exp( -16.0*x ) ) - 1.0',\n        cabecalho:'apply_sigmoid(in m matrix, out c matrix) RETURNS matrix',\n        parametros: [\n          parametroFactory.criar('m', 'matrix', 'Matriz de valores')\n        ],\n        retorno:[\n          retornoFactory.criar('c', 'matrix', 'Matriz com valores aplicados na função sigmoid')\n        ]\n      },\n      {\n        nome: 'blas_multiply',\n        descricao:'Função executa a multiplicação de duas matrizes. C = A * B',\n        cabecalho:'blas_multiply(a bigint, b bigint) RETURNS bigint',\n        parametros: [\n          parametroFactory.criar('A', 'bigint', 'Ponteiro para Matriz A'),\n          parametroFactory.criar('B', 'bigint', 'Ponteiro para Matriz B')\n        ],\n        retorno:[\n          retornoFactory.criar('C', 'bigint', 'Ponteiro para matriz resultante')\n        ]\n      },\n      {\n        nome: 'classe2vector',\n        descricao:'Transforma o conjunto de classes para vetores de valores 0 a 1',\n        cabecalho:'classe2vector(sql_distinct_classes text, OUT classe text, OUT vector double precision[]) RETURNS SETOF record',\n        parametros: [\n          parametroFactory.criar('sql_distinct_classes', 'text', \"EX: select * from classe2vector( 'select distinct classe from iris order by classe' )\")\n        ],\n        retorno:[\n          retornoFactory.criar('classe', 'matrix', 'Matriz com valores aplicados na função sigmoid'),\n          retornoFactory.criar('vector', 'double precision[]', 'Matriz com valores aplicados na função sigmoid')\n        ]\n      },\n      {\n        nome: 'cleanup_table',\n        descricao:'Zera ou cria uma tabela',\n        cabecalho:'cleanup_table(table_name text, table_columns text, make_temp bool)',\n        parametros: [\n          parametroFactory.criar('table_name', 'text', 'Nome da tabela'),\n          parametroFactory.criar('table_columns', 'text', \"Colunas da tabela. Ex: '( GRUPO INTEGER PRIMARY KEY, VALOR FLOAT8[] NOT NULL )'\"),\n          parametroFactory.criar('make_temp', 'bool', 'Se true, a tabela será temporária, caso contrário a tabela será permanente')\n        ],\n        retorno:[]\n      },\n      {\n        nome: 'cos',\n        descricao:'Aplica a função cosseno nos pontos',\n        cabecalho:['cos(a double precision[], b double precision[])','cos(a matrix, b matrix)'],\n        parametros: [\n          parametroFactory.criar('A', 'double precision[] | matrix', 'Matriz ou vetor A'),\n          parametroFactory.criar('B', 'double precision[] | matrix', 'Matriz ou vetor B')\n        ],\n        retorno:[\n          retornoFactory.criar('cosseno', 'double precision', 'Valor da função cosseno')\n        ]\n      },\n\n      {\n        nome: 'create_fann',\n        descricao:'Função cria um RNA baseada na struct da FANN',\n        cabecalho:\"create_fann(table_data text, layers integer[], validation_fold text DEFAULT '1'::text, test_fold text DEFAULT '1'::text, max_epochs integer DEFAULT 500, epochs_between_report integer DEFAULT 10, OUT net fann, OUT mse_train double precision, OUT mse_validation double precision, OUT mse_test double precision, OUT misclassified_train integer, OUT misclassified_validation integer, OUT misclassified_test integer) RETURNS SETOF record\",\n        parametros: [\n          parametroFactory.criar(\"table_data\", 'text','Deve ser uma tabela preparada por prepare_data_to_learn, tendo as colunas id, fold, entrada, saida, com entrada e saida normalizadas'),\n          parametroFactory.criar(\"layers\", 'integer[]','array com o número de neurônios das camadas intermediárias(hdden layers)'),\n          parametroFactory.criar(\"validation_fold\", 'text', \"fold de validação. default: 1\"),\n          parametroFactory.criar(\"test_fold\", 'text', 'fold de teste. default: 1'),\n          parametroFactory.criar(\"max_epochs\", 'integer', \"número máximo de épocas. default: 500\"),\n          parametroFactory.criar(\"epochs_between_report\", 'integer', \"número de epocas entre relatórios. default: 10\")\n        ],\n        retorno:[\n          retornoFactory.criar(\"mse_train\", \"double precision\", \"erro mínimo quadrado\"),\n          retornoFactory.criar(\"mse_validation\", \"double precision\", \"erro mínimo quadrado\"),\n          retornoFactory.criar(\"mse_test\", \"double precision\", \"erro mínimo quadrado\"),\n          retornoFactory.criar(\"misclassified_train\", \"integer\", \"acurácia\"),\n          retornoFactory.criar(\"misclassified_validation\", \"integer\", \"acurácia\"),\n          retornoFactory.criar(\"misclassified_test\", \"integer\", \"acurácia\")\n        ]\n      },\n      {\n        nome: 'create_nn',\n        descricao:'Função cria um RNA baseada na neuralnet',\n        cabecalho:'create_nn(table_data text, hidden integer[], functionActivation integer DEFAULT 3, steepness float default 0.01, validation_fold integer default 1, test_fold integer default 1, max_epochs integer default 500, epochs_between_report integer default 10, OUT nn neuralnet, OUT mse_report double precision[]) RETURNS record',\n        parametros: [\n          parametroFactory.criar('table_data', 'text','Deve ser uma tabela preparada por prepare_data_to_learn, tendo as colunas id, fold, entrada, saida, com entrada e saida normalizadas.'),\n          parametroFactory.criar('hidden', 'integer[]','array com o número de neurônios das camadas intermediárias(hdden layers)'),\n          parametroFactory.criar('functionActivation', 'integer', 'Função de ativação. Veja todos os valores em Função de Ativação: default: 3 (NN_SIGMOID)'),\n          parametroFactory.criar('steepness', 'float', 'valor do steepness. default: 0.01' ),\n          parametroFactory.criar('validation_fold', 'integer', 'fold de validação. default: 1' ),\n          parametroFactory.criar('test_fold', 'integer', 'fold de teste. default: 1' ),\n          parametroFactory.criar('max_epochs', 'integer', 'número máximo de épocas. default: 500' ),\n          parametroFactory.criar('epochs_between_report', 'integer', 'número de epocas entre relatórios. default: 10'),\n        ],\n        retorno:[\n          retornoFactory.criar('nn', 'neuralnet', 'RNA'),\n          retornoFactory.criar('mse_report', 'double precision[]', 'mínimo erro quadrado')\n        ]\n      },\n      {\n        nome: 'diag',\n        descricao:'Cria e retorna uma matrix diagonal [a] do tamanho de v.',\n        cabecalho:[\n          'diag(in v vector, out c matrix)',\n          'diag(size integer, a double precision DEFAULT 1.0, OUT c matrix)'\n        ],\n        parametros: [\n          parametroFactory.criar('v', 'vector', 'vetor que será transpassado para diagonal'),\n          parametroFactory.criar('size', 'integer', 'dimensão da matriz'),\n          parametroFactory.criar('a', 'double precision', 'valores que serão inseridos na diagonal default 1.0')\n        ],\n        retorno:[\n          retornoFactory.criar('c', 'matrix', 'matriz diagonal')\n        ]\n      },\n      {\n        nome: 'dims',\n        descricao:'Consegue as dimensões da matriz',\n        cabecalho:'dims(m matrix, OUT lines integer, OUT cols integer) RETURNS record',\n        parametros: [\n          parametroFactory.criar('m', 'matrix', 'Matriz de valores')\n        ],\n        retorno:[\n          retornoFactory.criar('lines', 'integer', 'Número de linhas da matriz'),\n          retornoFactory.criar('cols', 'integer', 'Número de colunas da matriz')\n        ]\n      },\n      {\n        nome: 'distancia',\n        descricao:'Distância de duas matrizes A e B',\n        cabecalho:'distancia(a matrix, b matrix, OUT valor double precision) RETURNS double precision',\n        parametros: [\n          parametroFactory.criar('A', 'matrix', 'Matriz de valores'),\n          parametroFactory.criar('B', 'matrix', 'Matriz de valores')\n        ],\n        retorno:[\n          retornoFactory.criar('distancia', 'double precision', 'distancia de duas matrizes')\n        ]\n      },\n      {\n        nome: 'dup',\n        descricao:'Duplica uma matriz',\n        cabecalho:'dup(m matrix, OUT c matrix) RETURNS matrix',\n        parametros: [\n          parametroFactory.criar('m', 'matrix', 'Matriz de valores')\n        ],\n        retorno:[\n          retornoFactory.criar('c', 'matrix', 'Matriz duplicada')\n        ]\n      },\n      {\n        nome: 'fann',\n        descricao:'Converte para o tipo fann',\n        cabecalho:'fann(ann bigint, OUT c fann) RETURNS fann',\n        parametros: [\n          parametroFactory.criar('ann', 'bigint', 'ponteiro para ann')\n        ],\n        retorno:[\n          retornoFactory.criar('ann', 'fann', 'Estrutura fann')\n        ]\n      },\n      {\n        nome: 'fann_create_train_data',\n        descricao:'Criar estrutura de dados para treinamento',\n        cabecalho:'fann_create_train_data(entrada matrix, saida matrix, OUT r traindata) RETURNS traindata',\n        parametros: [\n          parametroFactory.criar('entrada', 'matrix', 'matrix normalizada com os valores de entrada do treinamento'),\n          parametroFactory.criar('saída', 'matrix', 'matrix normalizada com os valores de saída. classificados')\n        ],\n        retorno:[\n          retornoFactory.criar('data', 'traindata', 'estrutura preparada para treinamento')\n        ]\n      },\n    ];\n  });\n\n})(angular.module('pgminer'));","(function(app){\n\napp.directive('pgmDocumentacao', function(){\n  return {\n    templateUrl: '/src/template/pgmdocumentacao.html',\n    restrict: 'EA',\n    scope: {\n      listaFuncao: '=lista'\n    },\n    controller: function($scope, $element, $attrs){\n      this.teste = function(){\n        alert($scope.listaFuncao);\n      };\n    },\n    link: function($scope,$element,$attr, ctrl){\n      $scope.escolhida = $scope.listaFuncao[0];\n      $scope.escolherFuncao = function(funcao){\n        $scope.escolhida = funcao;\n      };\n    }\n  };\n\n});\n\napp.directive('pgmFuncao', function(){\n  return {\n    scope: {\n      funcao: '='\n    },\n    restrict: 'EA',\n    templateUrl: '/src/template/pgmfuncao.html'\n  };\n});\n\n\n\n})(angular.module('pgminer'));","(function(app){\n\napp.service('parametroFactory', function(){\n  \n  this.criar = function(nome, tipo, descricao){\n    return {\n      nome: nome,\n      tipo: tipo,\n      descricao: descricao\n    }\n  };\n\n});\n\n})(angular.module('pgminer'));","(function(app){\n\napp.service('retornoFactory', function(){\n  \n  this.criar = function(nome, tipo, descricao){\n    return {\n      nome: nome,\n      tipo: tipo,\n      descricao: descricao\n    }\n  };\n\n});\n\n})(angular.module('pgminer'));"]}