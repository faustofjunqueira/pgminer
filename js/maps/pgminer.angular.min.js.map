{"version":3,"sources":["pgminer.angular.min.js","js/config/config.js","js/ctrl/docController.js","js/directive/documentation.js","js/service/funcaoFactory.js","js/service/operadorFactory.js","js/service/parametroFactory.js","js/service/retornoFactory.js","js/service/tipoFactory.js"],"names":["angular","module","app","controller","$scope","parametroFactory","retornoFactory","tipoFactory","operadorFactory","funcaoFactory","setup","lista","r","copy","i","tipo","funcoes","forEach","f","push","listaFuncoes","nome","descricao","cabecalho","parametros","criar","retorno","lang","campos","operador","directive","templateUrl","restrict","scope","listaFuncao","link","$element","$attr","ctrl","escolhida","escolherFuncao","funcao","isArray","e","Array","service","this","paramList","retList"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,ACLAA,QAAAC,OAAA,cAEA,aAEAD,QAAAC,OAAA,YCJA,SAAAC,KAEAA,IAAAC,WAAA,iBAAA,SAAA,mBAAA,iBAAA,cAAA,kBAAA,gBAAA,SAAAC,OAAAC,iBAAAC,eAAAC,YAAAC,gBAAAC,eAEA,QAAAC,OAAAC,OACA,GAAAC,GAAAZ,QAAAa,KAAAF,MACA,KAAA,GAAAG,KAAAH,OACAA,MAAAG,GAAAC,MACAJ,MAAAG,GAAAE,QAAAC,QAAA,SAAAC,GACAN,EAAAO,KAAAD,IAIA,OAAAN,GAGA,GAAAQ,gBAEAC,KAAA,wBACAC,UAAA,0HACAC,UAAA,kEACAC,YACAnB,iBAAAoB,MAAA,IAAA,SAAA,sBAEAC,SACApB,eAAAmB,MAAA,IAAA,SAAA,6CAIAJ,KAAA,gBACAC,UAAA,wGACAC,UAAA,0DACAC,YACAnB,iBAAAoB,MAAA,IAAA,SAAA,sBAEAC,SACApB,eAAAmB,MAAA,IAAA,SAAA,qDAIAJ,KAAA,gBACAC,UAAA,6DACAC,UAAA,mDACAC,YACAnB,iBAAAoB,MAAA,IAAA,SAAA,0BACApB,iBAAAoB,MAAA,IAAA,SAAA,2BAEAC,SACApB,eAAAmB,MAAA,IAAA,SAAA,sCAIAJ,KAAA,gBACAC,UAAA,iEACAC,UAAA,gHACAC,YACAnB,iBAAAoB,MAAA,uBAAA,OAAA,0FAEAC,SACApB,eAAAmB,MAAA,SAAA,SAAA,kDACAnB,eAAAmB,MAAA,SAAA,qBAAA,qDAIAJ,KAAA,gBACAC,UAAA,0BACAC,UAAA,qEACAC,YACAnB,iBAAAoB,MAAA,aAAA,OAAA,kBACApB,iBAAAoB,MAAA,gBAAA,OAAA,mFACApB,iBAAAoB,MAAA,YAAA,OAAA,+EAEAC,aAGAL,KAAA,MACAC,UAAA,qCACAC,WAAA,kDAAA,2BACAC,YACAnB,iBAAAoB,MAAA,IAAA,8BAAA,qBACApB,iBAAAoB,MAAA,IAAA,8BAAA,sBAEAC,SACApB,eAAAmB,MAAA,UAAA,mBAAA,8BAKAJ,KAAA,cACAC,UAAA,+CACAC,UAAA,mbACAC,YACAnB,iBAAAoB,MAAA,aAAA,OAAA,wIACApB,iBAAAoB,MAAA,SAAA,YAAA,4EACApB,iBAAAoB,MAAA,kBAAA,OAAA,iCACApB,iBAAAoB,MAAA,YAAA,OAAA,6BACApB,iBAAAoB,MAAA,aAAA,UAAA,yCACApB,iBAAAoB,MAAA,wBAAA,UAAA,mDAEAC,SACApB,eAAAmB,MAAA,YAAA,mBAAA,wBACAnB,eAAAmB,MAAA,iBAAA,mBAAA,wBACAnB,eAAAmB,MAAA,WAAA,mBAAA,wBACAnB,eAAAmB,MAAA,sBAAA,UAAA,YACAnB,eAAAmB,MAAA,2BAAA,UAAA,YACAnB,eAAAmB,MAAA,qBAAA,UAAA,eAIAJ,KAAA,YACAC,UAAA,0CACAC,UAAA,iUACAC,YACAnB,iBAAAoB,MAAA,aAAA,OAAA,yIACApB,iBAAAoB,MAAA,SAAA,YAAA,4EACApB,iBAAAoB,MAAA,qBAAA,UAAA,4FACApB,iBAAAoB,MAAA,YAAA,QAAA,qCACApB,iBAAAoB,MAAA,kBAAA,UAAA,iCACApB,iBAAAoB,MAAA,YAAA,UAAA,6BACApB,iBAAAoB,MAAA,aAAA,UAAA,yCACApB,iBAAAoB,MAAA,wBAAA,UAAA,mDAEAC,SACApB,eAAAmB,MAAA,KAAA,YAAA,OACAnB,eAAAmB,MAAA,aAAA,qBAAA,2BAIAJ,KAAA,OACAC,UAAA,0DACAC,WACA,kCACA,oEAEAC,YACAnB,iBAAAoB,MAAA,IAAA,SAAA,6CACApB,iBAAAoB,MAAA,OAAA,UAAA,sBACApB,iBAAAoB,MAAA,IAAA,mBAAA,wDAEAC,SACApB,eAAAmB,MAAA,IAAA,SAAA,sBAIAJ,KAAA,OACAC,UAAA,kCACAC,UAAA,qEACAC,YACAnB,iBAAAoB,MAAA,IAAA,SAAA,sBAEAC,SACApB,eAAAmB,MAAA,QAAA,UAAA,8BACAnB,eAAAmB,MAAA,OAAA,UAAA,kCAIAJ,KAAA,YACAC,UAAA,mCACAC,UAAA,qFACAC,YACAnB,iBAAAoB,MAAA,IAAA,SAAA,qBACApB,iBAAAoB,MAAA,IAAA,SAAA,sBAEAC,SACApB,eAAAmB,MAAA,YAAA,mBAAA,iCAIAJ,KAAA,MACAC,UAAA,qBACAC,UAAA,6CACAC,YACAnB,iBAAAoB,MAAA,IAAA,SAAA,sBAEAC,SACApB,eAAAmB,MAAA,IAAA,SAAA,uBAIAJ,KAAA,OACAC,UAAA,4BACAC,UAAA,4CACAC,YACAnB,iBAAAoB,MAAA,MAAA,SAAA,sBAEAC,SACApB,eAAAmB,MAAA,MAAA,OAAA,qBAIAJ,KAAA,yBACAC,UAAA,4CACAC,UAAA,0FACAC,YACAnB,iBAAAoB,MAAA,UAAA,SAAA,+DACApB,iBAAAoB,MAAA,QAAA,SAAA,8DAEAC,SACApB,eAAAmB,MAAA,OAAA,YAAA,2CAIAJ,KAAA,OACAC,UAAA,sBACAC,UAAA,8BACAC,YACAnB,iBAAAoB,MAAA,IAAA,SAAA,sBAEAC,aAGAL,KAAA,UACAC,UAAA,iCACAC,UAAA,4DACAC,YACAnB,iBAAAoB,MAAA,IAAA,SAAA,qBACApB,iBAAAoB,MAAA,MAAA,UAAA,qBAEAC,SACApB,eAAAmB,MAAA,SAAA,qBAAA,qCAIAJ,KAAA,WACAC,UAAA,gCACAC,UAAA,8DACAC,YACAnB,iBAAAoB,MAAA,IAAA,SAAA,qBACApB,iBAAAoB,MAAA,OAAA,UAAA,oBAEAC,SACApB,eAAAmB,MAAA,OAAA,qBAAA,oCAIAJ,KAAA,MACAC,UAAA,2BACAC,UAAA,6CACAC,YACAnB,iBAAAoB,MAAA,IAAA,SAAA,sBAEAC,SACApB,eAAAmB,MAAA,IAAA,SAAA,0BAIAJ,KAAA,kBACAC,UAAA,gFACAC,WACA,mEACA,gEAEAC,YACAnB,iBAAAoB,MAAA,IAAA,qBAAA,uDACApB,iBAAAoB,MAAA,IAAA,mBAAA,mCAEAC,SACApB,eAAAmB,MAAA,MAAA,qBAAA,iCACAnB,eAAAmB,MAAA,MAAA,mBAAA,kCAIAJ,KAAA,oBACAC,UAAA,gEACAC,UAAA,uGACAC,YACAnB,iBAAAoB,MAAA,MAAA,OAAA,2EACApB,iBAAAoB,MAAA,OAAA,OAAA,6RACApB,iBAAAoB,MAAA,UAAA,OAAA,0GAEAC,SACApB,eAAAmB,MAAA,SAAA,SAAA,mCAIAJ,KAAA,cACAC,UAAA,qCACAC,UAAA,2EACAC,YACAnB,iBAAAoB,MAAA,MAAA,OAAA,kVAEAC,SACApB,eAAAmB,MAAA,SAAA,SAAA,wBACAnB,eAAAmB,MAAA,OAAA,SAAA,yEAIAJ,KAAA,qBACAC,UAAA,0CACAC,UAAA,qIACAC,YACAnB,iBAAAoB,MAAA,UAAA,UAAA,oBACApB,iBAAAoB,MAAA,SAAA,UAAA,qBACApB,iBAAAoB,MAAA,IAAA,mBAAA,cACApB,iBAAAoB,MAAA,IAAA,mBAAA,gBAEAC,SACApB,eAAAmB,MAAA,SAAA,SAAA,2BAIAJ,KAAA,SACAC,UAAA,mBACAC,WACA,yDACA,8EACA,iDAEAC,YACAnB,iBAAAoB,MAAA,aAAA,SAAA,0BACApB,iBAAAoB,MAAA,sBAAA,qBAAA,sCACApB,iBAAAoB,MAAA,MAAA,OAAA,+BAEAC,SACApB,eAAAmB,MAAA,IAAA,SAAA,yBAIAJ,KAAA,eACAC,UAAA,4BACAC,WACA,gGACA,yGACA,mHAEAC,YACAnB,iBAAAoB,MAAA,SAAA,SAAA,qBACApB,iBAAAoB,MAAA,aAAA,SAAA,mCACApB,iBAAAoB,MAAA,OAAA,SAAA,oDACApB,iBAAAoB,MAAA,aAAA,OAAA,mBAEAC,SACApB,eAAAmB,MAAA,SAAA,UAAA,8BACAnB,eAAAmB,MAAA,QAAA,UAAA,kCAIAJ,KAAA,yBACAC,UAAA,8CACAC,WACA,+GACA,6HAEAC,YACAnB,iBAAAoB,MAAA,SAAA,SAAA,mCACApB,iBAAAoB,MAAA,OAAA,SAAA,oDACApB,iBAAAoB,MAAA,aAAA,OAAA,mBAEAC,SACApB,eAAAmB,MAAA,SAAA,UAAA,8BACAnB,eAAAmB,MAAA,QAAA,UAAA,kCAIAJ,KAAA,MACAC,UAAA,wBACAC,UAAA,uEACAC,YACAnB,iBAAAoB,MAAA,IAAA,mBAAA,yBACApB,iBAAAoB,MAAA,IAAA,mBAAA,0BAEAC,SACApB,eAAAmB,MAAA,MAAA,mBAAA,0BAIAJ,KAAA,WACAC,UAAA,0CACAC,UAAA,0DACAC,YACAnB,iBAAAoB,MAAA,IAAA,qBAAA,qBAEAC,SACApB,eAAAmB,MAAA,MAAA,mBAAA,uCAIAJ,KAAA,MACAC,UAAA,wBACAC,UAAA,uEACAC,YACAnB,iBAAAoB,MAAA,IAAA,mBAAA,yBACApB,iBAAAoB,MAAA,IAAA,mBAAA,0BAEAC,SACApB,eAAAmB,MAAA,MAAA,mBAAA,0BAIAJ,KAAA,QACAC,UAAA,4CACAC,UAAA,oDACAC,YACAnB,iBAAAoB,MAAA,IAAA,SAAA,sBAEAC,SACApB,eAAAmB,MAAA,OAAA,UAAA,oCAIAJ,KAAA,SACAC,UAAA,2CACAC,UAAA,uDACAC,YACAnB,iBAAAoB,MAAA,IAAA,SAAA,sBAEAC,SACApB,eAAAmB,MAAA,SAAA,UAAA,mCAIAJ,KAAA,OACAC,UAAA,6BACAC,WAAA,sDAAA,2CACAC,YACAnB,iBAAAoB,MAAA,IAAA,qBAAA,oBACApB,iBAAAoB,MAAA,IAAA,SAAA,sBAEAC,SACApB,eAAAmB,MAAA,OAAA,mBAAA,qBAKAJ,KAAA,kBACAC,UAAA,mCACAC,UAAA,4DACAC,YACAnB,iBAAAoB,MAAA,UAAA,UAAA,yBAEAC,SACApB,eAAAmB,MAAA,QAAA,UAAA,iCAIAJ,KAAA,aACAC,UAAA,+CACAC,UAAA,oJACAC,YACAnB,iBAAAoB,MAAA,SAAA,SAAA,oBACApB,iBAAAoB,MAAA,IAAA,UAAA,8BACApB,iBAAAoB,MAAA,OAAA,UAAA,uGACApB,iBAAAoB,MAAA,MAAA,UAAA,0JAEAC,SACApB,eAAAmB,MAAA,YAAA,SAAA,0CACAnB,eAAAmB,MAAA,SAAA,SAAA,2OACAnB,eAAAmB,MAAA,OAAA,mBAAA,6BAIAJ,KAAA,UACAC,UAAA,yCACAC,UAAA,2DACAC,YACAnB,iBAAAoB,MAAA,IAAA,SAAA,qBACApB,iBAAAoB,MAAA,IAAA,SAAA,sBAEAC,SACApB,eAAAmB,MAAA,UAAA,SAAA,0BAKAJ,KAAA,YACAC,UAAA,+OACAP,MACAM,KAAA,YACAM,KAAA,IACAC,QACArB,YAAAkB,MAAA,OAAA,MAAA,6BACAlB,YAAAkB,MAAA,UAAA,iBAAA,qBACAlB,YAAAkB,MAAA,qBAAA,iBAAA,gCACAlB,YAAAkB,MAAA,uBAAA,eAAA,kDACAlB,YAAAkB,MAAA,eAAA,eAAA,8CACAlB,YAAAkB,MAAA,eAAA,eAAA,wCACAlB,YAAAkB,MAAA,OAAA,eAAA,oCACAlB,YAAAkB,MAAA,YAAA,SAAA,6DACAlB,YAAAkB,MAAA,MAAA,SAAA,wEACAlB,YAAAkB,MAAA,qBAAA,SAAA,mDACAlB,YAAAkB,MAAA,iBAAA,SAAA,mDACAlB,YAAAkB,MAAA,iBAAA,SAAA,mDACAlB,YAAAkB,MAAA,WAAA,SAAA,6DACAlB,YAAAkB,MAAA,WAAA,SAAA,gEACAlB,YAAAkB,MAAA,YAAA,SAAA,8DACAlB,YAAAkB,MAAA,YAAA,SAAA,gEACAlB,YAAAkB,MAAA,6BAAA,eAAA,iFACAlB,YAAAkB,MAAA,aAAA,SAAA,iUAGAI,UACArB,gBAAAiB,MAAA,IAAA,UAAA,+CACAjB,gBAAAiB,MAAA,IAAA,qBAAA,2FAEAT,SACAP,cAAAgB,MAAA,kBAAA,gDAAA,gCACApB,iBAAAoB,MAAA,KAAA,UAAA,iEAEAnB,eAAAmB,MAAA,KAAA,YAAA,wBAEAhB,cAAAgB,MAAA,mBAAA,8CAAA,6BACApB,iBAAAoB,MAAA,KAAA,YAAA,sCAEAnB,eAAAmB,MAAA,KAAA,UAAA,qBAEAhB,cAAAgB,MAAA,eAAA,6DAAA,yCACApB,iBAAAoB,MAAA,MAAA,YAAA,uBACApB,iBAAAoB,MAAA,MAAA,YAAA,yBAEAnB,eAAAmB,MAAA,KAAA,UAAA,2CAEAhB,cAAAgB,MAAA,kBAAA,sFAAA,0DACApB,iBAAAoB,MAAA,MAAA,YAAA,OACApB,iBAAAoB,MAAA,SAAA,qBAAA,iCAEAnB,eAAAmB,MAAA,gBAAA,qBAAA,iDAEAhB,cAAAgB,MAAA,sBAAA,6EAAA,oCACApB,iBAAAoB,MAAA,MAAA,YAAA,OACApB,iBAAAoB,MAAA,MAAA,YAAA,SAEAnB,eAAAmB,MAAA,YAAA,mBAAA,6BAEAhB,cAAAgB,MAAA,iBAAA,wDAAA,gCACApB,iBAAAoB,MAAA,KAAA,YAAA,SAEAnB,eAAAmB,MAAA,MAAA,mBAAA,0BAEAhB,cAAAgB,MAAA,qBAAA,sKAAA,2BACApB,iBAAAoB,MAAA,MAAA,YAAA,SAEAnB,eAAAmB,MAAA,YAAA,mBAAA,0BACAnB,eAAAmB,MAAA,YAAA,mBAAA,0BACAnB,eAAAmB,MAAA,aAAA,mBAAA,2BACAnB,eAAAmB,MAAA,aAAA,mBAAA,6BAEAhB,cAAAgB,MAAA,0BAAA,sEAAA,uCACApB,iBAAAoB,MAAA,KAAA,YAAA,OACApB,iBAAAoB,MAAA,QAAA,UAAA,qBAEAnB,eAAAmB,MAAA,MAAA,SAAA,4DAEAhB,cAAAgB,MAAA,mBAAA,iDAAA,iDACApB,iBAAAoB,MAAA,KAAA,YAAA,SAEAnB,eAAAmB,MAAA,YAAA,UAAA,yBAEAhB,cAAAgB,MAAA,eAAA,+DAAA,+TACApB,iBAAAoB,MAAA,MAAA,YAAA,OACApB,iBAAAoB,MAAA,MAAA,YAAA,SAEAnB,eAAAmB,MAAA,KAAA,YAAA,oBAEAhB,cAAAgB,MAAA,wBAAA,qDAAA,sDACApB,iBAAAoB,MAAA,KAAA,YAAA,SAEAnB,eAAAmB,MAAA,WAAA,SAAA,4BAEAhB,cAAAgB,MAAA,iBAAA,8CAAA,kCACApB,iBAAAoB,MAAA,KAAA,YAAA,SAEAnB,eAAAmB,MAAA,UAAA,YAAA,oCAEAhB,cAAAgB,MAAA,oBAAA,kDAAA,gDACApB,iBAAAoB,MAAA,KAAA,YAAA,SAEAnB,eAAAmB,MAAA,aAAA,UAAA,yBAEAhB,cAAAgB,MAAA,iBAAA,kFAAA,+CACApB,iBAAAoB,MAAA,KAAA,YAAA,OACApB,iBAAAoB,MAAA,UAAA,mBAAA,yBAEAnB,eAAAmB,MAAA,MAAA,mBAAA,cAEAhB,cAAAgB,MAAA,qBAAA,uKAAA,aACApB,iBAAAoB,MAAA,KAAA,YAAA,OACApB,iBAAAoB,MAAA,YAAA,mBAAA,+BACApB,iBAAAoB,MAAA,YAAA,mBAAA,+BACApB,iBAAAoB,MAAA,aAAA,mBAAA,gCACApB,iBAAAoB,MAAA,aAAA,mBAAA,kCAEAnB,eAAAmB,MAAA,KAAA,YAAA,iCAEAhB,cAAAgB,MAAA,0BAAA,wFAAA,gCACApB,iBAAAoB,MAAA,KAAA,YAAA,OACApB,iBAAAoB,MAAA,SAAA,SAAA,kEACApB,iBAAAoB,MAAA,QAAA,UAAA,0BAEAnB,eAAAmB,MAAA,KAAA,YAAA,iCAEAhB,cAAAgB,MAAA,eAAA,iGAAA,wCACApB,iBAAAoB,MAAA,KAAA,YAAA,OACApB,iBAAAoB,MAAA,QAAA,UAAA,uCAEAnB,eAAAmB,MAAA,MAAA,YAAA,uDACAnB,eAAAmB,MAAA,MAAA,YAAA,wDAEAhB,cAAAgB,MAAA,cAAA,0FAAA,uDACApB,iBAAAoB,MAAA,YAAA,SAAA,6DACApB,iBAAAoB,MAAA,aAAA,SAAA,2DACApB,iBAAAoB,MAAA,KAAA,YAAA,SAEAnB,eAAAmB,MAAA,WAAA,mBAAA,wBAMAJ,KAAA,OACAC,UAAA,4CACAP,MACAM,KAAA,OACAM,KAAA,WACAC,QACArB,YAAAkB,MAAA,MAAA,SAAA,kCAGAI,UACArB,gBAAAiB,MAAA,IAAA,qBAAA,mDAEAT,SACAP,cAAAgB,MAAA,6BAAA,mEAAA,gCACApB,iBAAAoB,MAAA,OAAA,SAAA,kCAEAnB,eAAAmB,MAAA,MAAA,qBAAA,0BAEAhB,cAAAgB,MAAA,wBAAA,uDAAA,yCACApB,iBAAAoB,MAAA,OAAA,SAAA,kCAEAnB,eAAAmB,MAAA,KAAA,YAAA,oBAEAhB,cAAAgB,MAAA,gCAAA,mGAAA,oFACApB,iBAAAoB,MAAA,oBAAA,SAAA,wDACApB,iBAAAoB,MAAA,qBAAA,SAAA,wDAEAnB,eAAAmB,MAAA,aAAA,SAAA,wBAEAhB,cAAAgB,MAAA,8BAAA,8DAAA,uBACApB,iBAAAoB,MAAA,aAAA,SAAA,iCAEAhB,cAAAgB,MAAA,kBAAA,oFAAA,0DACApB,iBAAAoB,MAAA,MAAA,SAAA,mCACApB,iBAAAoB,MAAA,SAAA,qBAAA,4CAEAnB,eAAAmB,MAAA,gBAAA,qBAAA,iDAEAhB,cAAAgB,MAAA,mBAAA,qGAAA,uDACApB,iBAAAoB,MAAA,aAAA,SAAA,sCACApB,iBAAAoB,MAAA,MAAA,SAAA,kCAEAnB,eAAAmB,MAAA,MAAA,mBAAA,0BAEAhB,cAAAgB,MAAA,oBAAA,0NAAA,kCACApB,iBAAAoB,MAAA,aAAA,SAAA,sCACApB,iBAAAoB,MAAA,eAAA,YAAA,kDACApB,iBAAAoB,MAAA,qBAAA,UAAA,+BACApB,iBAAAoB,MAAA,YAAA,mBAAA,sBACApB,iBAAAoB,MAAA,aAAA,UAAA,0CACApB,iBAAAoB,MAAA,yBAAA,UAAA,sCACApB,iBAAAoB,MAAA,gBAAA,mBAAA,mBAEAnB,eAAAmB,MAAA,KAAA,SAAA,yDAMArB,QAAAO,MAAAD,MAAAU,kBAGApB,QAAAC,OAAA,YC9pBA,SAAAC,KAEAA,IAAA4B,UAAA,kBAAA,WACA,OACAC,YAAA,6CACAC,SAAA,KACAC,OACAC,YAAA,UAEAC,KAAA,SAAA/B,OAAAgC,SAAAC,MAAAC,MACAlC,OAAAmC,UAAAnC,OAAA8B,YAAA,GACA9B,OAAAoC,eAAA,SAAAC,QACArC,OAAAmC,UAAAE,YAOAvC,IAAA4B,UAAA,YAAA,WACA,OACAG,OACAQ,OAAA,KAEAT,SAAA,KACAD,YAAA,uCACA5B,YAAA,SAAA,SAAAC,QACAA,OAAAsC,QAAA,SAAAC,GACA,MAAAC,OAAAF,QAAAC,SAMAzC,IAAA4B,UAAA,UAAA,WACA,OACAG,OACAQ,OAAA,KAEAT,SAAA,KACAD,YAAA,qCACA5B,YAAA,SAAA,SAAAC,QACAA,OAAAsC,QAAA,SAAAC,GACA,MAAAC,OAAAF,QAAAC,UAMA3C,QAAAC,OAAA,YCjDA,SAAAC,KAEAA,IAAA2C,QAAA,gBAAA,WAEAC,KAAArB,MAAA,SAAAJ,KAAAE,UAAAD,UAAAyB,UAAAC,SACA,OACA3B,KAAAA;AACAE,UAAAA,UACAD,UAAAA,UACAE,WAAAuB,UACArB,QAAAsB,aAMAhD,QAAAC,OAAA,YCfA,SAAAC,KAEAA,IAAA2C,QAAA,kBAAA,WAEAC,KAAArB,MAAA,SAAAI,SAAAd,KAAA0B,QACA,OACAZ,SAAAA,SACAd,KAAAA,KACA0B,OAAAA,YAMAzC,QAAAC,OAAA,YCfA,SAAAC,KAEAA,IAAA2C,QAAA,mBAAA,WAEAC,KAAArB,MAAA,SAAAJ,KAAAN,KAAAO,WACA,OACAD,KAAAA,KACAN,KAAAA,KACAO,UAAAA,eAMAtB,QAAAC,OAAA,YCdA,SAAAC,KAEAA,IAAA2C,QAAA,iBAAA,WAEAC,KAAArB,MAAA,SAAAJ,KAAAN,KAAAO,WACA,OACAD,KAAAA,KACAN,KAAAA,KACAO,UAAAA,eAMAtB,QAAAC,OAAA,YCbA,SAAAC,KAEAA,IAAA2C,QAAA,cAAA,WAEAC,KAAArB,MAAA,SAAAJ,KAAAN,KAAAO,WACA,OACAD,KAAAA,KACAN,KAAAA,KACAO,UAAAA,eAMAtB,QAAAC,OAAA","file":"../pgminer.angular.min.js","sourcesContent":[null,"angular.module('pgminer',[]);\n\n(function(){\n\n})(angular.module('pgminer'));","(function(app){\n\n  app.controller('DocController', function($scope,parametroFactory, retornoFactory, tipoFactory, operadorFactory, funcaoFactory){\n\n    function setup(lista){\n      var r = angular.copy(lista);\n      for(var i in lista){\n        if(lista[i].tipo){\n          lista[i].funcoes.forEach(function(f){\n            r.push(f);\n          });\n        }\n      }\n      return r;\n    }\n\n    var listaFuncoes = [\n      {\n        nome: 'apply_inverse_sigmoid',\n        descricao:'Aplica a função inversa da sigmoid sobre cada elemento x 1da matriz m. Inversa da sigmoid: -log( 2.0/(x+1.0) -1.0)/16.0',\n        cabecalho:'apply_inverse_sigmoid(in m matrix, out c matrix) RETURNS matrix',\n        parametros: [\n          parametroFactory.criar('m', 'matrix', 'Matriz de valores')\n        ],\n        retorno:[\n          retornoFactory.criar('c', 'matrix', 'Matriz com valores aplicados na função')\n        ]\n      },\n      {\n        nome: 'apply_sigmoid',\n        descricao:'Aplica a função sigmoid sobre cada elemento x da matriz m. Sigmoid: 2.0/(1.0 + exp( -16.0*x ) ) - 1.0',\n        cabecalho:'apply_sigmoid(in m matrix, out c matrix) RETURNS matrix',\n        parametros: [\n          parametroFactory.criar('m', 'matrix', 'Matriz de valores')\n        ],\n        retorno:[\n          retornoFactory.criar('c', 'matrix', 'Matriz com valores aplicados na função sigmoid')\n        ]\n      },\n      {\n        nome: 'blas_multiply',\n        descricao:'Função executa a multiplicação de duas matrizes. C = A * B',\n        cabecalho:'blas_multiply(a bigint, b bigint) RETURNS bigint',\n        parametros: [\n          parametroFactory.criar('A', 'bigint', 'Ponteiro para Matriz A'),\n          parametroFactory.criar('B', 'bigint', 'Ponteiro para Matriz B')\n        ],\n        retorno:[\n          retornoFactory.criar('C', 'bigint', 'Ponteiro para matriz resultante')\n        ]\n      },\n      {\n        nome: 'classe2vector',\n        descricao:'Transforma o conjunto de classes para vetores de valores 0 a 1',\n        cabecalho:'classe2vector(sql_distinct_classes text, OUT classe text, OUT vector double precision[]) RETURNS SETOF record',\n        parametros: [\n          parametroFactory.criar('sql_distinct_classes', 'text', \"EX: select * from classe2vector( 'select distinct classe from iris order by classe' )\")\n        ],\n        retorno:[\n          retornoFactory.criar('classe', 'matrix', 'Matriz com valores aplicados na função sigmoid'),\n          retornoFactory.criar('vector', 'double precision[]', 'Matriz com valores aplicados na função sigmoid')\n        ]\n      },\n      {\n        nome: 'cleanup_table',\n        descricao:'Zera ou cria uma tabela',\n        cabecalho:'cleanup_table(table_name text, table_columns text, make_temp bool)',\n        parametros: [\n          parametroFactory.criar('table_name', 'text', 'Nome da tabela'),\n          parametroFactory.criar('table_columns', 'text', \"Colunas da tabela. Ex: '( GRUPO INTEGER PRIMARY KEY, VALOR FLOAT8[] NOT NULL )'\"),\n          parametroFactory.criar('make_temp', 'bool', 'Se true, a tabela será temporária, caso contrário a tabela será permanente')\n        ],\n        retorno:[]\n      },\n      {\n        nome: 'cos',\n        descricao:'Aplica a função cosseno nos pontos',\n        cabecalho:['cos(a double precision[], b double precision[])','cos(a matrix, b matrix)'],\n        parametros: [\n          parametroFactory.criar('A', 'double precision[] | matrix', 'Matriz ou vetor A'),\n          parametroFactory.criar('B', 'double precision[] | matrix', 'Matriz ou vetor B')\n        ],\n        retorno:[\n          retornoFactory.criar('cosseno', 'double precision', 'Valor da função cosseno')\n        ]\n      },\n\n      {\n        nome: 'create_fann',\n        descricao:'Função cria um RNA baseada na struct da FANN',\n        cabecalho:\"create_fann(table_data text, layers integer[], validation_fold text DEFAULT '1'::text, test_fold text DEFAULT '1'::text, max_epochs integer DEFAULT 500, epochs_between_report integer DEFAULT 10, OUT net fann, OUT mse_train double precision, OUT mse_validation double precision, OUT mse_test double precision, OUT misclassified_train integer, OUT misclassified_validation integer, OUT misclassified_test integer) RETURNS SETOF record\",\n        parametros: [\n          parametroFactory.criar(\"table_data\", 'text','Deve ser uma tabela preparada por prepare_data_to_learn, tendo as colunas id, fold, entrada, saida, com entrada e saida normalizadas'),\n          parametroFactory.criar(\"layers\", 'integer[]','array com o número de neurônios das camadas intermediárias(hdden layers)'),\n          parametroFactory.criar(\"validation_fold\", 'text', \"fold de validação. default: 1\"),\n          parametroFactory.criar(\"test_fold\", 'text', 'fold de teste. default: 1'),\n          parametroFactory.criar(\"max_epochs\", 'integer', \"número máximo de épocas. default: 500\"),\n          parametroFactory.criar(\"epochs_between_report\", 'integer', \"número de epocas entre relatórios. default: 10\")\n        ],\n        retorno:[\n          retornoFactory.criar(\"mse_train\", \"double precision\", \"erro mínimo quadrado\"),\n          retornoFactory.criar(\"mse_validation\", \"double precision\", \"erro mínimo quadrado\"),\n          retornoFactory.criar(\"mse_test\", \"double precision\", \"erro mínimo quadrado\"),\n          retornoFactory.criar(\"misclassified_train\", \"integer\", \"acurácia\"),\n          retornoFactory.criar(\"misclassified_validation\", \"integer\", \"acurácia\"),\n          retornoFactory.criar(\"misclassified_test\", \"integer\", \"acurácia\")\n        ]\n      },\n      {\n        nome: 'create_nn',\n        descricao:'Função cria um RNA baseada na neuralnet',\n        cabecalho:'create_nn(table_data text, hidden integer[], functionActivation integer DEFAULT 3, steepness float default 0.01, validation_fold integer default 1, test_fold integer default 1, max_epochs integer default 500, epochs_between_report integer default 10, OUT nn neuralnet, OUT mse_report double precision[]) RETURNS record',\n        parametros: [\n          parametroFactory.criar('table_data', 'text','Deve ser uma tabela preparada por prepare_data_to_learn, tendo as colunas id, fold, entrada, saida, com entrada e saida normalizadas.'),\n          parametroFactory.criar('hidden', 'integer[]','array com o número de neurônios das camadas intermediárias(hdden layers)'),\n          parametroFactory.criar('functionActivation', 'integer', 'Função de ativação. Veja todos os valores em Função de Ativação: default: 3 (NN_SIGMOID)'),\n          parametroFactory.criar('steepness', 'float', 'valor do steepness. default: 0.01' ),\n          parametroFactory.criar('validation_fold', 'integer', 'fold de validação. default: 1' ),\n          parametroFactory.criar('test_fold', 'integer', 'fold de teste. default: 1' ),\n          parametroFactory.criar('max_epochs', 'integer', 'número máximo de épocas. default: 500' ),\n          parametroFactory.criar('epochs_between_report', 'integer', 'número de epocas entre relatórios. default: 10'),\n        ],\n        retorno:[\n          retornoFactory.criar('nn', 'neuralnet', 'RNA'),\n          retornoFactory.criar('mse_report', 'double precision[]', 'mínimo erro quadrado')\n        ]\n      },\n      {\n        nome: 'diag',\n        descricao:'Cria e retorna uma matrix diagonal [a] do tamanho de v.',\n        cabecalho:[\n          'diag(in v vector, out c matrix)',\n          'diag(size integer, a double precision DEFAULT 1.0, OUT c matrix)'\n        ],\n        parametros: [\n          parametroFactory.criar('v', 'vector', 'vetor que será transpassado para diagonal'),\n          parametroFactory.criar('size', 'integer', 'dimensão da matriz'),\n          parametroFactory.criar('a', 'double precision', 'valores que serão inseridos na diagonal default 1.0')\n        ],\n        retorno:[\n          retornoFactory.criar('c', 'matrix', 'matriz diagonal')\n        ]\n      },\n      {\n        nome: 'dims',\n        descricao:'Consegue as dimensões da matriz',\n        cabecalho:'dims(m matrix, OUT lines integer, OUT cols integer) RETURNS record',\n        parametros: [\n          parametroFactory.criar('m', 'matrix', 'Matriz de valores')\n        ],\n        retorno:[\n          retornoFactory.criar('lines', 'integer', 'Número de linhas da matriz'),\n          retornoFactory.criar('cols', 'integer', 'Número de colunas da matriz')\n        ]\n      },\n      {\n        nome: 'distancia',\n        descricao:'Distância de duas matrizes A e B',\n        cabecalho:'distancia(a matrix, b matrix, OUT valor double precision) RETURNS double precision',\n        parametros: [\n          parametroFactory.criar('A', 'matrix', 'Matriz de valores'),\n          parametroFactory.criar('B', 'matrix', 'Matriz de valores')\n        ],\n        retorno:[\n          retornoFactory.criar('distancia', 'double precision', 'distancia de duas matrizes')\n        ]\n      },\n      {\n        nome: 'dup',\n        descricao:'Duplica uma matriz',\n        cabecalho:'dup(m matrix, OUT c matrix) RETURNS matrix',\n        parametros: [\n          parametroFactory.criar('m', 'matrix', 'Matriz de valores')\n        ],\n        retorno:[\n          retornoFactory.criar('c', 'matrix', 'Matriz duplicada')\n        ]\n      },\n      {\n        nome: 'fann',\n        descricao:'Converte para o tipo fann',\n        cabecalho:'fann(ann bigint, OUT c fann) RETURNS fann',\n        parametros: [\n          parametroFactory.criar('ann', 'bigint', 'ponteiro para ann')\n        ],\n        retorno:[\n          retornoFactory.criar('ann', 'fann', 'Estrutura fann')\n        ]\n      },\n      {\n        nome: 'fann_create_train_data',\n        descricao:'Criar estrutura de dados para treinamento',\n        cabecalho:'fann_create_train_data(entrada matrix, saida matrix, OUT r traindata) RETURNS traindata',\n        parametros: [\n          parametroFactory.criar('entrada', 'matrix', 'matrix normalizada com os valores de entrada do treinamento'),\n          parametroFactory.criar('saída', 'matrix', 'matrix normalizada com os valores de saída. classificados')\n        ],\n        retorno:[\n          retornoFactory.criar('data', 'traindata', 'estrutura preparada para treinamento')\n        ]\n      },\n      {\n        nome: 'free',\n        descricao:'Desaloca uma matriz',\n        cabecalho:'free(m matrix) RETURNS void',\n        parametros: [\n          parametroFactory.criar('m', 'matrix', 'Matriz de valores')\n        ],\n        retorno:[]\n      },\n      {\n        nome: 'get_col',\n        descricao:'Retorna a coluna de uma matriz',\n        cabecalho:'get_col(m matrix, col integer) RETURNS double precision[]',\n        parametros: [\n          parametroFactory.criar('m', 'matrix', 'Matriz de valores'),\n          parametroFactory.criar('col', 'integer', 'índice da coluna'),\n        ],\n        retorno:[\n          retornoFactory.criar('coluna', 'double precision[]', 'array com os valores da coluna')\n        ]\n      },\n      {\n        nome: 'get_line',\n        descricao:'Retorna a linha de uma matriz',\n        cabecalho:'get_line(m matrix, line integer) RETURNS double precision[]',\n        parametros: [\n          parametroFactory.criar('m', 'matrix', 'Matriz de valores'),\n          parametroFactory.criar('line', 'integer', 'índice da linha')\n        ],\n        retorno:[\n          retornoFactory.criar('line', 'double precision[]', 'array com os valores da linha')\n        ]\n      },\n      {\n        nome: 'inv',\n        descricao:'Retorna a matriz inversa',\n        cabecalho:'inv(m matrix, OUT c matrix) RETURNS matrix',\n        parametros: [\n          parametroFactory.criar('m', 'matrix', 'Matriz de valores')\n        ],\n        retorno:[\n          retornoFactory.criar('c', 'matrix', 'matriz inversa de m')\n        ]\n      },\n      {\n        nome: 'inverse_sigmoid',\n        descricao:'Retorna o valor da sigmoid inversa. Inversa da sigmoid: ln( x/(1.0 - x) )/2.0',\n        cabecalho:[\n          'inverse_sigmoid(a double precision[]) RETURNS double precision[]',\n          'inverse_sigmoid(e double precision) RETURNS double precision'\n        ],\n        parametros: [\n          parametroFactory.criar('a', 'double precision[]', 'array de valores que serão aplicados a x na função '),\n          parametroFactory.criar('x', 'double precision', 'valor a ser aplicado na função')\n        ],\n        retorno:[\n          retornoFactory.criar('inv', 'double precision[]', 'valores da inversa da sigmoid'),\n          retornoFactory.criar('inv', 'double precision', 'valor da inversa da sigmoid')\n        ]\n      },\n      {\n        nome: 'make_dense_matrix',\n        descricao:\"Cria uma matiz densa a partir de um SQL de uma matriz esparsa\",\n        cabecalho:\"make_dense_matrix(sql text, zero text DEFAULT ''::text, centrar boolean DEFAULT true) RETURNS bigint\",\n        parametros: [\n          parametroFactory.criar('sql', 'text', \"SQL de uma matriz esparsa do tipo 'select linha, coluna, valor from ...\"),\n          parametroFactory.criar('zero', 'text', \"significa que zero é zero; não haverá substituição; 'mavg' significa substituir zero pela média dos valores da matriz inteira; 'lavg' significa substituir os zeros de cada linha pela média de cada linha; 'cavg' significa substituir os zeros de cada coluna pela média de cada coluna\"),\n          parametroFactory.criar('centrar', 'bool', \"centrar a média em zero, o que equivale a subtrair de cada valor diferente de zero a média escolhida.\"),\n        ],\n        retorno:[\n          retornoFactory.criar('matrix', 'bigint', \"ponteiro para a matriz densa\")\n        ]\n      },\n      {\n        nome: 'make_matrix',\n        descricao:'Cria uma matriz a partir de um sql',\n        cabecalho:'make_matrix(sql text, OUT matrix bigint, OUT keys bigint) RETURNS record',\n        parametros: [\n          parametroFactory.criar('sql', 'text', \"'sql' deve ser uma string retornando (id,valor), onde 'id integer primary key' e valor é um array float8[] com os valores do ponto, ou uma tabela/view com as colunas id::integer, valor::float8[] EX1: 'select id, array[ x, y ] valor from tabela' EX2: 'select cast( row_number() over() as integer ) id, array[ x, y ] valor from tabela'\")\n        ],\n        retorno:[\n          retornoFactory.criar('matrix', 'bigint', \"ponteiro para matrix\"),\n          retornoFactory.criar('keys', 'bigint', \"ponteiro para vetor contendo a chave (id) de cada linha da matriz.\")\n        ]\n      },\n      {\n        nome: 'make_random_matrix',\n        descricao:'Criar uma matriz com valores randômicos',\n        cabecalho:'make_random_matrix(n_lines integer, n_cols integer, a double precision DEFAULT 0.0, b double precision DEFAULT 1.0) RETURNS bigint',\n        parametros: [\n          parametroFactory.criar('n_lines', 'integer', 'número de linhas'),\n          parametroFactory.criar('n_cols', 'integer', 'número de colunas'),\n          parametroFactory.criar('a', 'double precision', 'valores de'),\n          parametroFactory.criar('b', 'double precision', 'valores até'),\n        ],\n        retorno:[\n          retornoFactory.criar('matrix', 'bigint', 'ponteiro para matriz')\n        ]\n      },\n      {\n        nome: 'matrix',\n        descricao:'Criar uma matrix',\n        cabecalho:[\n          'matrix(ptr_matrix bigint, OUT c matrix) RETURNS matrix',\n          'matrix(bidimensional_array double precision[], OUT c matrix) RETURNS matrix',\n          'matrix(sql text, OUT c matrix) RETURNS matrix'\n        ],\n        parametros: [\n          parametroFactory.criar('ptr_matrix', 'bigint', 'ponteiro para a matrix'),\n          parametroFactory.criar('bidimensional_array','double precision[]', 'array de valores de duas dimensões'),\n          parametroFactory.criar('sql','text', 'sql similar ao make_matrix')\n        ],\n        retorno:[\n          retornoFactory.criar('c', 'matrix', 'matrix estruturada')\n        ]\n      },\n      {\n        nome: 'matrix2table',\n        descricao:'Converte matriz em tabela',\n        cabecalho:[\n          'matrix2table(m matrix, table_name text, OUT nlines integer, OUT ncols integer) RETURNS record',\n          'matrix2table(ptr_matrix bigint, table_name text, OUT nlines integer, OUT ncols integer) RETURNS record',\n          'matrix2table(keys bigint, matrix bigint, table_name text, OUT nlines integer, OUT ncols integer) RETURNS record'\n        ],\n        parametros: [\n          parametroFactory.criar('matrix', 'matrix', 'Matriz de valores'),\n          parametroFactory.criar('ptr_matrix', 'bigint', 'ponteiro para matriz de valores'),\n          parametroFactory.criar('keys', 'bigint', 'ponteiro para vetor com as chaves da nova tabela'),\n          parametroFactory.criar('table_name', 'text', 'nome da tabela'),\n        ],\n        retorno:[\n          retornoFactory.criar('nlines', 'integer', 'número de linhas da tabela'),\n          retornoFactory.criar('ncols', 'integer', 'número de colunas da tabela'),\n        ]\n      },\n      {\n        nome: 'matrix2table_transpose',\n        descricao:'Converte matriz em tabela, com a transposta',\n        cabecalho:[\n          'matrix2table_transpose(matrix bigint, table_name text, OUT nlines integer, OUT ncols integer) RETURNS record',\n          'matrix2table_transpose(keys bigint, matrix bigint, table_name text, OUT nlines integer, OUT ncols integer) RETURNS record'\n        ],\n        parametros: [\n          parametroFactory.criar('matrix', 'bigint', 'ponteiro para matriz de valores'),\n          parametroFactory.criar('keys', 'bigint', 'ponteiro para vetor com as chaves da nova tabela'),\n          parametroFactory.criar('table_name', 'text', 'nome da tabela'),\n        ],\n        retorno:[\n          retornoFactory.criar('nlines', 'integer', 'número de linhas da tabela'),\n          retornoFactory.criar('ncols', 'integer', 'número de colunas da tabela'),\n        ]\n      },\n      {\n        nome: 'max',\n        descricao:'Retorna o maior valor',\n        cabecalho:'max(a double precision, b double precision) RETURNS double precision',\n        parametros: [\n          parametroFactory.criar('a', 'double precision', 'valor a ser comparado'),\n          parametroFactory.criar('b', 'double precision', 'valor a ser comparado'),\n        ],\n        retorno:[\n          retornoFactory.criar('max', 'double precision', 'max = a > b ? a : b')\n        ]\n      },\n      {\n        nome: 'max_elem',\n        descricao:'Retorna o maior valor presente no array',\n        cabecalho:'max_elem(a double precision[]) RETURNS double precision',\n        parametros: [\n          parametroFactory.criar('a', 'double precision[]', 'array de valores')\n        ],\n        retorno:[\n          retornoFactory.criar('max', 'double precision', 'elemento de maior valor no array')\n        ]\n      },\n      {\n        nome: 'min',\n        descricao:'Retorna o menor valor',\n        cabecalho:'min(a double precision, b double precision) RETURNS double precision',\n        parametros: [\n          parametroFactory.criar('a', 'double precision', 'valor a ser comparado'),\n          parametroFactory.criar('b', 'double precision', 'valor a ser comparado'),\n        ],\n        retorno:[\n          retornoFactory.criar('min', 'double precision', 'max = a < b ? a : b')\n        ]\n      },\n      {\n        nome: 'ncols',\n        descricao:'Retorna o número de colunas de uma matrix',\n        cabecalho:'ncols(m matrix, OUT cols integer) RETURNS integer',\n        parametros: [\n          parametroFactory.criar('m', 'matrix', 'Matriz de valores')\n        ],\n        retorno:[\n          retornoFactory.criar('cols', 'integer', 'Número de colunas da matriz m')\n        ]\n      },\n      {\n        nome: 'nlines',\n        descricao:'Retorna o número de linhas de uma matrix',\n        cabecalho:'nlines(m matrix, OUT nlines integer) RETURNS integer',\n        parametros: [\n          parametroFactory.criar('m', 'matrix', 'Matriz de valores')\n        ],\n        retorno:[\n          retornoFactory.criar('nlines', 'integer', 'Número de linhas da matriz m')\n        ]\n      },\n      {\n        nome: 'norm',\n        descricao:'Retorna a norma do array a',\n        cabecalho:['norm(a double precision[]) RETURNS double precision','norm(m matrix) RETURNS double precision'],\n        parametros: [\n          parametroFactory.criar('a', 'double precision[]', 'array de valores'),\n          parametroFactory.criar('m', 'matrix', 'matriz de valores')\n        ],\n        retorno:[\n          retornoFactory.criar('norm', 'double precision', 'norma do array')\n        ]\n      },\n      \n      {\n        nome: 'pgm_hello_world',\n        descricao:'Função de Hello World do Pgminer',\n        cabecalho:'FUNCTION pgm_hello_world(entrada CSTRING) RETURNS CSTRING',\n        parametros: [\n          parametroFactory.criar('entrada', 'CSTRING', 'uma palavra qualquer')\n        ],\n        retorno:[\n          retornoFactory.criar('saida', 'CSTRING', 'a mesma palavra da entrada')\n        ]\n      },\n      {\n        nome: 'pgm_kmeans',\n        descricao:'Executa o algoritmo de clusterização k-means',\n        cabecalho:'pgm_kmeans(pontos bigint, k integer, seed integer, fim integer, OUT centroide bigint, OUT grupo bigint, OUT sumd double precision) RETURNS record',\n        parametros: [\n          parametroFactory.criar('pontos', 'bigint', 'matriz de pontos'),\n          parametroFactory.criar('k', 'integer', 'número de grupos desejados'),\n          parametroFactory.criar('seed', 'integer', '1 - para sortear k pontos para serem os centros dos grupos; 2 - para sortear cada ponto em um grupo'),\n          parametroFactory.criar('fim', 'integer', '1 - se um Grupo Secar , Elimine - o; 2 - se um Grupo Secar , cria um grupo com o elemento mais longe de seu centroide; 3 - se um Grupo Secar , Erro .'),\n        ],\n        retorno:[\n          retornoFactory.criar('centroide', 'bigint', 'ponteiro para matriz com os centroídes'),\n          retornoFactory.criar('grupos', 'bigint', 'O grupo é um ponteiro para vetor de n posições, onde n é o número total de pontos p k , que armazena na posição i, onde i é o índice na matriz correspondente ao ponto p i , o grupo que o ponto p i está alocado. Logo, gi = grupo(pi)'),\n          retornoFactory.criar('sumd', 'double precision', 'soma quadrática mínima'),\n        ]\n      },\n      {\n        nome: 'pgm_cos',\n        descricao:'Aplica função cosseno em duas matrizes',\n        cabecalho:'pgm_cos(matrix_a bigint, matrix_b bigint) RETURNS bigint',\n        parametros: [\n          parametroFactory.criar('a', 'bigint', 'Matriz de valores'),\n          parametroFactory.criar('b', 'bigint', 'Matriz de valores'),\n        ],\n        retorno:[\n          retornoFactory.criar('cosseno', 'bigint', 'ponteiro para vetor')\n        ]\n      },\n\n      {\n        nome: 'neuralnet',\n        descricao:'Módulo de operação da RNA (rede neural artificial) que é possivel serializar e inserir em tabelas. Serialização da neuralnet: #NumeroDeCamadas#NeuroniosPorCamada#FunçãoDeAtivação#InputMin InputMax OutputMin OutputMax#Stepness#Bias#Pesos',\n        tipo: {\n          nome: 'neuralnet',\n          lang: 'C',\n          campos: [\n            tipoFactory.criar('size', 'int', 'tamanho de byte da struct'),\n            tipoFactory.criar('NLayers', 'unsigned short', 'numero de camadas'),\n            tipoFactory.criar('FunctionActivation', 'unsigned short', 'codigo da função de ativação'),\n            tipoFactory.criar('NNeurons[MAX_LAYERS]', 'unsigned int', 'numero de neuronios por camada. MAX_LAYERS = 5'),\n            tipoFactory.criar('TotalNeurons', 'unsigned int', 'numero total de neurônios presentes na ANN'),\n            tipoFactory.criar('TotalWeights', 'unsigned int', 'Número total de pesos da rede neural'),\n            tipoFactory.criar('Bias', 'unsigned int', 'Utilizado na conversão para FANN'),\n            tipoFactory.criar('Steepness', 'double', 'Valor do Steepness. Parâmetro de compatibilidade com Fann'),\n            tipoFactory.criar('MSE', 'double', 'Valor do Erro mínimo quadrado. Parâmetro de compatibilidade com Fann'),\n            tipoFactory.criar('BihiperbolicLambda', 'double', 'Parâmetros da função de ativação bi-hiperbolica'),\n            tipoFactory.criar('BihiperbolicT1', 'double', 'Parâmetros da função de ativação bi-hiperbolica'),\n            tipoFactory.criar('BihiperbolicT2', 'double', 'Parâmetros da função de ativação bi-hiperbolica'),\n            tipoFactory.criar('InputMin', 'double', 'Limite de input mínimo. Parâmetros de escala. Default = 0'),\n            tipoFactory.criar('InputMax', 'double', 'Limite de inpute máximo. Parâmetros de escala. Default = 1.0'),\n            tipoFactory.criar('OutputMin', 'double', 'Limite de output mínimo. Parâmetros de escala. Default = 0'),\n            tipoFactory.criar('OutputMax', 'double', 'Limite de output máximo. Parâmetros de escala. Default = 1.0'),\n            tipoFactory.criar('WeightsPos[MAX_LAYERS - 1]', 'unsigned int', 'Vetor com o indice que inicia a sequencia de pesos da camada no vetor Weights'),\n            tipoFactory.criar('Weights[0]','double', 'Vetor que guarda os valores dos neuronios e os pesos. Para acessar os pesos basta da um GetWeght(layer). OBS: Pesos: primeira camada: Bias[layer][i] - Neuron[layer+1][i]; Neuron[layer][j] - Neuron[layer+1][i]; Neuron[layer][j+1] - Neuron[layer+1][i]; assim sucessivamente. Lembrando que a ultima camada nao tem Bias')\n          ]\n        },\n        operador: [\n          operadorFactory.criar('/','integer','opr_nn_split_part - Ex: neuralnet / integer'),\n          operadorFactory.criar('*','double precision[]','pgm_nn_evaluate - Ex: neuralnet * double precision[] ou double precision[] * neuralnet')\n        ],\n        funcoes: [\n          funcaoFactory.criar('pgm_neuralnetin', 'pgm_neuralnetin(st cstring) RETURNS neuralnet','De-Serialização de neuralnet', [\n            parametroFactory.criar('st','cstring','String de neuralnet serializado utilizando pgm_neuralnetout'),\n          ],[\n            retornoFactory.criar('nn','neuralnet','RNA de-serializada'),\n          ]),\n          funcaoFactory.criar('pgm_neuralnetout', 'pgm_neuralnetout(neuralnet) RETURNS cstring','Serialização de neuralnet', [\n            parametroFactory.criar('nn','neuralnet','neuralnet para a ser serializada'),\n          ],[\n            retornoFactory.criar('st','cstring','RNA serializada'),\n          ]),\n          funcaoFactory.criar('pgm_nn_equal', 'pgm_nn_equal(nn1 neuralnet, nn2 neuralnet) RETURNS boolean','Compara se duas neuralnets são iguais', [\n            parametroFactory.criar('nn1','neuralnet','RNA a ser comparada'),\n            parametroFactory.criar('nn2','neuralnet','RNA a ser comparada'),\n          ],[\n            retornoFactory.criar('eq','boolean','True se iguais, caso contrário, False'),\n          ]),\n          funcaoFactory.criar('pgm_nn_evaluate', 'pgm_nn_evaluate(nn neuralnet, vector double precision[]) RETURNS double precision[]','Função que valida a rede para uma determinada entrada.', [\n            parametroFactory.criar('nn1','neuralnet','RNA'),\n            parametroFactory.criar('vector','double precision[]','registro a ser classificado'),\n          ],[\n            retornoFactory.criar('classificacao','double precision[]','Vetor com a probabiblidade de classificacao'),\n          ]),\n          funcaoFactory.criar('pgm_nn_get_distance', 'pgm_nn_get_distance(nna neuralnet, nnb neuralnet) RETURNS double precision','Obtem a distância entre as redes', [\n            parametroFactory.criar('nna','neuralnet','RNA'),\n            parametroFactory.criar('nnb','neuralnet','RNA'),\n          ],[\n            retornoFactory.criar('distancia','double precision','Distância entre as RNAs'),\n          ]),\n          funcaoFactory.criar('pgm_nn_get_mse', 'pgm_nn_get_mse(nn neuralnet) RETURNS double precision','Obtem o erro mínimo quadrado', [\n            parametroFactory.criar('nn','neuralnet','RNA'),\n          ],[\n            retornoFactory.criar('mse','double precision','Erro mínimo quadrado'),\n          ]),\n          funcaoFactory.criar('pgm_nn_get_scaling', 'pgm_nn_get_scaling(nn neuralnet, OUT input_min double precision, OUT input_max double precision, OUT output_min double precision, OUT output_max double precision) ','Obtem as escalas da RNA',  [\n            parametroFactory.criar('nn1','neuralnet','RNA'),\n          ],[\n            retornoFactory.criar('input_min','double precision','Limite mínimo de input'),\n            retornoFactory.criar('input_max','double precision','Limite máximo de input'),\n            retornoFactory.criar('output_min','double precision','Limite mínimo de output'),\n            retornoFactory.criar('output_max','double precision','Limite máximo de output'),\n          ]),\n          funcaoFactory.criar('pgm_nn_get_weight_array', 'pgm_nn_get_weight_array(nn neuralnet, layer integer) RETURNS bigint','Obtem os pesos de uma camada da RNA',  [\n            parametroFactory.criar('nn','neuralnet','RNA'),\n            parametroFactory.criar('layer','integer','camada desejada'),\n          ],[\n            retornoFactory.criar('ptr','bigint','ponteiro para pgm_vector_double com os pesos da camada'),\n          ]),\n          funcaoFactory.criar('pgm_nn_inputsize', 'pgm_nn_inputsize(nn neuralnet) RETURNS integer','Obtem o número de neurônio da primeira camada',  [\n            parametroFactory.criar('nn','neuralnet','RNA'),\n          ],[\n            retornoFactory.criar('inputsize','integer','Número de neurônios'),\n          ]),\n          funcaoFactory.criar('pgm_nn_merge', 'pgm_nn_merge(nna neuralnet, nnb neuralnet) RETURNS neuralnet','Mescla duas RNAs. Condição: nna->OutputMin == 0.0; nna->OutputMax == 1.0; nnb->InputMin == 0.0; nnb->InputMax == 1.0; nna->NLayers + nnb->NLayers - 1 >= 5; nna->NNeurons[nna->NLayers-1] == nnb->NNeurons[0]; nna->FunctionActivation == nnb->FunctionActivation; nna->Bias == nnb->Bias; nna->Steepness == nnb->Steepness', [\n            parametroFactory.criar('nna','neuralnet','RNA'),\n            parametroFactory.criar('nnb','neuralnet','RNA'),\n          ],[\n            retornoFactory.criar('nn','neuralnet','RNAs mescladas'),\n          ]),\n          funcaoFactory.criar('pgm_nn_neuralnet2fann', 'pgm_nn_neuralnet2fann(nn neuralnet) RETURNS bigint','Converte RNA do tipo neuralnet em RNA do tipo fann',  [\n            parametroFactory.criar('nn','neuralnet','RNA'),\n          ],[\n            retornoFactory.criar('fann_ptr','bigint','ponteiro para RNA fann'),\n          ]),\n          funcaoFactory.criar('pgm_nn_nlayers', 'pgm_nn_nlayers(neuralnet) RETURNS integer[]','Número de neurônios por camada',  [\n            parametroFactory.criar('nn','neuralnet','RNA'),\n          ],[\n            retornoFactory.criar('nlayers','integer[]','Número de neurônios por camada'),\n          ]),\n          funcaoFactory.criar('pgm_nn_outputsize', 'pgm_nn_outputsize(nn neuralnet) RETURNS integer','Obtem o número de neurônios da última camada', [\n            parametroFactory.criar('nn','neuralnet','RNA'),\n          ],[\n            retornoFactory.criar('outputsize','integer','Número de neurônios'),\n          ]),\n          funcaoFactory.criar('pgm_nn_set_mse', 'pgm_nn_set_mse(nn neuralnet, new_mse double precision) RETURNS double precision','Troca o MSE(erro mínimo quadrado) de um RNA', [\n            parametroFactory.criar('nn','neuralnet','RNA'),\n            parametroFactory.criar('new_mse','double precision','Novo valor para mse'),\n          ],[\n            retornoFactory.criar('mse','double precision','Novo MSE'),\n          ]),\n          funcaoFactory.criar('pgm_nn_set_scaling', 'pgm_nn_set_scaling(nn neuralnet, input_min double precision, input_max double precision, output_min double precision, output_max double precision) RETURNS neuralnet','descricao', [\n            parametroFactory.criar('nn','neuralnet','RNA'),\n            parametroFactory.criar('input_min','double precision','Novo limite mínimo de input'),\n            parametroFactory.criar('input_max','double precision','Novo limite máximo de input'),\n            parametroFactory.criar('output_min','double precision','Novo limite mínimo de output'),\n            parametroFactory.criar('output_max','double precision','Novo limite máximo de output'),\n          ],[\n            retornoFactory.criar('nn','neuralnet','RNA com as escalas trocadas'),\n          ]),\n          funcaoFactory.criar('pgm_nn_set_weight_array', 'pgm_nn_set_weight_array(nn neuralnet, matrix bigint, layer integer) RETURNS neuralnet','Troca os pesos de uma camada', [\n            parametroFactory.criar('nn','neuralnet','RNA'),\n            parametroFactory.criar('matrix','bigint','Ponteiro para pgm_matrix_double com os novos pesos para camada'),\n            parametroFactory.criar('layer','integer','Camada a ser trocada'),\n          ],[\n            retornoFactory.criar('nn','neuralnet','RNA com as escalas trocadas'),\n          ]),\n          funcaoFactory.criar('pgm_nn_split', 'pgm_nn_split(nn neuralnet, split integer, OUT nn1 neuralnet, OUT nn2 neuralnet) RETURNS record','Função que quebra a rede em 2 partes', [\n            parametroFactory.criar('nn','neuralnet','RNA'),\n            parametroFactory.criar('layer','integer','camada onde será efetuada a cisão'),\n          ],[\n            retornoFactory.criar('nn1','neuralnet','RNA correspondente à primeira parte da RNA anterior'),\n            retornoFactory.criar('nn2','neuralnet','RNA correspondente à segunda parte da RNA anterior'),\n          ]),\n          funcaoFactory.criar('pgm_nn_test', 'pgm_nn_test(matrix_in bigint, matrix_out bigint, nn neuralnet) RETURNS double precision','Efetua teste na RNA com um dado conjunto de entrada',[\n            parametroFactory.criar('matrix_in','bigint','ponteiro para pgm_matrix_double com o conjunto de entrada'),\n            parametroFactory.criar('matrix_out','bigint','ponteiro para pgm_matrix_double com o conjunto de saída'),\n            parametroFactory.criar('nn','neuralnet','RNA'),\n          ],[\n            retornoFactory.criar('accurate','double precision','Acurácia da RNA'),\n          ]),\n        ]\n      },\n\n      {\n        nome: 'fann',\n        descricao:'Estrutura para ponteiro da estrutura fann',\n        tipo: {\n          nome: 'fann',\n          lang: 'pgPL/SQL',\n          campos: [\n            tipoFactory.criar('ann', 'bigint', 'ponteiro para struct da fann'),\n          ]\n        },\n        operador: [\n          operadorFactory.criar('*','double precision[]','opr_fann_apply - Ex: double precision[] / fann'),\n        ],\n        funcoes: [\n          funcaoFactory.criar('pgm_nn_fann_get_mse_report','pgm_nn_fann_get_mse_report(fann bigint) RETURNS double precision','Obtem o erro mínimo quadrado',[\n            parametroFactory.criar('fann','bigint','ponteiro para estrutura fann'),\n          ],[\n            retornoFactory.criar('mse','double precision[]','Erro mínimo quadrado'),\n          ]),\n          funcaoFactory.criar('pgm_nn_fann2neuralnet','pgm_nn_fann2neuralnet(fann bigint) RETURNS neuralnet','Converte ponteiro fann para neuralnet',[\n            parametroFactory.criar('fann','bigint','Ponteiro para estrutura fann'),\n          ],[\n            retornoFactory.criar('nn','neuralnet','RNA convertida'),\n          ]),\n          funcaoFactory.criar('pgm_nn_fann_create_train_data','pgm_nn_fann_create_train_data(data_matrix_input bigint, data_matrix_ouput bigint) RETURNS bigint','Cria estrutura de dados para treinamento. Recomendado usar prepare_data_to_learn',[\n            parametroFactory.criar('data_matrix_input','bigint','ponteiro para pgm_matrix_double com dados de entrada'),\n            parametroFactory.criar('data_matrix_output','bigint','ponteiro para pgm_matrix_double com dados de saída'),\n          ],[\n            retornoFactory.criar('train_data','bigint','RNA de-serializada'),\n          ]),\n          funcaoFactory.criar('pgm_nn_fann_free_train_data','pgm_nn_fann_free_train_data(train_data bigint) RETURNS void','Desaloca train_data',[\n            parametroFactory.criar('train_data','bigint','ponteiro para train_data'),\n          ],[]),\n          funcaoFactory.criar('pgm_nn_fann_run','pgm_nn_fann_run(ann bigint, _input double precision[]) RETURNS double precision[]','Função que valida a rede para uma determinada entrada.',[\n            parametroFactory.criar('ann','bigint','ponteiro para estrutura da fann'),\n            parametroFactory.criar('_input','double precision[]','registro de entrada a ser classificado'),\n          ],[\n            retornoFactory.criar('classificacao','double precision[]','Vetor com a probabiblidade de classificacao'),\n          ]),\n          funcaoFactory.criar('pgm_nn_fann_test','pgm_nn_fann_test(train_data bigint, ann bigint, OUT mse double precision) RETURNS double precision','Efetua teste na RNA com um dado conjunto de entrada',[\n            parametroFactory.criar('train_data','bigint','Ponteiro para estrutura train_data'),\n            parametroFactory.criar('ann','bigint','Ponteiro para estrutura fann'),\n          ],[\n            retornoFactory.criar('mse','double precision','Erro mínino quadrado'),\n          ]),\n          funcaoFactory.criar('pgm_nn_fann_train','pgm_nn_fann_train(train_data bigint, hidden_layer integer[], functionActivation integer, steepness double precision, max_epochs integer, epochs_between_reports integer, desired_error double precision) RETURNS bigint','Executa treinamento de uma RNA',[\n            parametroFactory.criar('train_data','bigint','Ponteiro para estrutura train_data'),\n            parametroFactory.criar('hidden_layer', 'integer[]', 'Número de neurônios nas camadas intermediária.'),\n            parametroFactory.criar('functionActivation', 'integer', 'Valor da função de Ativação'),\n            parametroFactory.criar('steepness', 'double precision', 'Valor de steepness'),\n            parametroFactory.criar('max_epochs', 'integer', 'Número máximo de épocas para convergir'),\n            parametroFactory.criar('epochs_between_reports', 'integer', 'Número de epocas entre relatórios.'),\n            parametroFactory.criar('desired_error', 'double precision', 'Erro desejado'),\n          ],[\n            retornoFactory.criar('nn','bigint','Ponteiro para RNA criada. No formato de neuralnet'),\n          ])\n        ]\n      }\n    ];\n\n    $scope.lista = setup(listaFuncoes);\n  });\n\n})(angular.module('pgminer'));","(function(app){\n\napp.directive('pgmDocumentacao', function(){\n  return {\n    templateUrl: '/pgminer/src/template/pgmdocumentacao.html',\n    restrict: 'EA',\n    scope: {\n      listaFuncao: '=lista'\n    },\n    link: function($scope,$element,$attr, ctrl){\n      $scope.escolhida = $scope.listaFuncao[0];\n      $scope.escolherFuncao = function(funcao){\n        $scope.escolhida = funcao;\n      };\n    }\n  };\n\n});\n\napp.directive('pgmFuncao', function(){\n  return {\n    scope: {\n      funcao: '='\n    },\n    restrict: 'EA',\n    templateUrl: '/pgminer/src/template/pgmfuncao.html',\n    controller: function($scope){\n      $scope.isArray = function(e){\n        return Array.isArray(e);\n      }\n    }\n  };\n});\n\napp.directive('pgmTipo', function(){\n  return {\n    scope: {\n      funcao: '='\n    },\n    restrict: 'EA',\n    templateUrl: '/pgminer/src/template/pgmtipo.html',\n    controller: function($scope){\n      $scope.isArray = function(e){\n        return Array.isArray(e);\n      }\n    }\n  };\n});\n\n})(angular.module('pgminer'));","(function(app){\n\napp.service('funcaoFactory', function(){\n  \n  this.criar = function(nome, cabecalho, descricao, paramList, retList){\n    return {\n      nome: nome,\n      cabecalho: cabecalho,\n      descricao: descricao,\n      parametros: paramList,\n      retorno: retList\n    };\n  };\n\n});\n\n})(angular.module('pgminer'));","\n(function(app){\n\napp.service('operadorFactory', function(){\n  \n  this.criar = function(operador, tipo, funcao){\n    return {\n      operador: operador,\n      tipo: tipo,\n      funcao: funcao\n    }\n  };\n\n});\n\n})(angular.module('pgminer'));","(function(app){\n\napp.service('parametroFactory', function(){\n  \n  this.criar = function(nome, tipo, descricao){\n    return {\n      nome: nome,\n      tipo: tipo,\n      descricao: descricao\n    }\n  };\n\n});\n\n})(angular.module('pgminer'));","(function(app){\n\napp.service('retornoFactory', function(){\n  \n  this.criar = function(nome, tipo, descricao){\n    return {\n      nome: nome,\n      tipo: tipo,\n      descricao: descricao\n    }\n  };\n\n});\n\n})(angular.module('pgminer'));","\n(function(app){\n\napp.service('tipoFactory', function(){\n  \n  this.criar = function(nome, tipo, descricao){\n    return {\n      nome: nome,\n      tipo: tipo,\n      descricao: descricao\n    }\n  };\n\n});\n\n})(angular.module('pgminer'));"]}